## Audit Report

# Title
Module Account Name-Address Validation Bypass Through Unenforced Genesis Validation

## Summary
The module account validation at account.go:227-229 correctly checks name-derived address correctness, but this validation is not enforced during genesis initialization. InitGenesis loads module accounts directly into state without calling Validate(), allowing module accounts with mismatched name-address pairs to be loaded if ValidateGenesis is not run. [1](#0-0) 

## Impact
**Medium** - Results in unintended smart contract behavior with potential for authorization bypass and permission violations in module accounts.

## Finding Description

**Location:** 
- Validation logic: `x/auth/types/account.go` lines 227-229 in `ModuleAccount.Validate()`
- Genesis loading: `x/auth/genesis.go` lines 22-24 in `InitGenesis()`
- Account retrieval: `x/auth/keeper/keeper.go` lines 187-193 in `GetModuleAccountAndPermissions()` [2](#0-1) [3](#0-2) 

**Intended Logic:** 
Module accounts must have addresses that are cryptographically derived from their names using `crypto.AddressHash([]byte(ma.Name))`. This ensures deterministic address-name binding and prevents permission confusion. The validation exists to enforce this invariant.

**Actual Logic:** 
While `ModuleAccount.Validate()` correctly checks the name-address binding, this validation is only called by the optional `ValidateGenesis` CLI command. The `InitGenesis` function directly loads accounts using `ak.SetAccount(ctx, acc)` without calling `Validate()`, bypassing the check. Additionally, `GetModuleAccountAndPermissions` retrieves accounts by computing the address from the module name but does not verify the retrieved account's name matches. [4](#0-3) 

**Exploit Scenario:**
1. Genesis file (generated by tooling or manually created) contains a ModuleAccount with Address = `DeriveAddress("distribution")` but Name = "malicious_module" with Permissions = `[minter, burner]`
2. Operators skip running the optional `validate-genesis` CLI command before chain start
3. `InitGenesis` loads this malformed account directly into state without validation
4. When distribution module code calls `GetModuleAccount("distribution")`, it computes the correct address from "distribution" and retrieves the malicious account at that address
5. The distribution module now operates with an account that has the wrong name and potentially wrong permissions [5](#0-4) 

**Security Failure:** 
The authorization and permission model for module accounts is violated. Module accounts are expected to have names matching their addresses, and specific permissions tied to those names. This bypass allows accounts with arbitrary names/permissions to occupy addresses reserved for legitimate modules, breaking the permission isolation model.

## Impact Explanation

Module accounts control critical protocol functions including:
- Minting and burning tokens (mint module, distribution module)
- Holding bonded validator stakes (staking module)  
- Managing community pool funds (distribution module)
- Fee collection and distribution

If a module account has mismatched name-permissions:
- A module expecting specific permissions might get an account with different permissions
- Permission checks via `ValidatePermissions` use the registered name, not the account's stored name, creating a mismatch
- Funds could be minted, burned, or transferred based on incorrect permission assumptions
- The integrity of module isolation is compromised [6](#0-5) 

While no direct fund theft occurs, this violates critical protocol invariants and could enable unauthorized state transitions affecting the entire network.

## Likelihood Explanation

**Triggering Conditions:**
- Requires malformed genesis file (through tooling bugs, manual errors, or corrupted files during generation/transmission)
- Requires operators to skip the `validate-genesis` CLI command (which is optional, not automatic)

**Who Can Trigger:**
- Not directly exploitable by unprivileged users post-genesis
- Can occur through operator error, automated genesis generation bugs, or genesis migration script errors

**Frequency:**
- Most likely during initial chain launch or major upgrades involving genesis export/import
- Genesis files are typically reviewed, but automated tooling bugs could introduce malformed accounts unnoticed
- Once loaded at genesis, the invalid state persists indefinitely

The issue sits at the boundary of operational procedure and code enforcement - while operators should run validation, the code should defensively validate critical security properties rather than relying solely on optional CLI commands.

## Recommendation

**Primary Fix:** Enforce validation in `InitGenesis`:

Modify `x/auth/genesis.go` to call `Validate()` on each account before storing:

```go
for _, a := range accounts {
    // Add validation before creating account
    if err := a.Validate(); err != nil {
        panic(fmt.Errorf("invalid account in genesis: %w", err))
    }
    acc := ak.NewAccount(ctx, a)
    ak.SetAccount(ctx, acc)
}
```

**Secondary Fix:** Add name verification in `GetModuleAccountAndPermissions`:

In `x/auth/keeper/keeper.go`, verify the retrieved account's name matches the requested module name:

```go
if acc != nil {
    macc, ok := acc.(types.ModuleAccountI)
    if !ok {
        panic("account is not a module account")
    }
    // Add name verification
    if macc.GetName() != moduleName {
        panic(fmt.Sprintf("module account name mismatch: expected %s, got %s", moduleName, macc.GetName()))
    }
    return macc, perms
}
```

## Proof of Concept

**Test File:** `x/auth/keeper/keeper_test.go`

**Test Function:** `TestModuleAccountNameAddressMismatch`

```go
func TestModuleAccountNameAddressMismatch(t *testing.T) {
    app, ctx := createTestApp(true)
    
    // Create a malicious module account with wrong name for the address
    // Address is derived from "distribution", but name is "attacker"
    distributionAddr := types.NewModuleAddress("distribution")
    baseAcc := types.NewBaseAccountWithAddress(distributionAddr)
    maliciousModAcc := types.NewModuleAccount(baseAcc, "attacker", types.Minter, types.Burner)
    
    // Validation should fail
    err := maliciousModAcc.Validate()
    require.Error(t, err)
    require.Contains(t, err.Error(), "cannot be derived from the module name")
    
    // But SetAccount allows it (bypass validation)
    app.AccountKeeper.SetAccount(ctx, maliciousModAcc)
    
    // When we call GetModuleAccount("distribution"), it retrieves the malicious account
    retrievedAcc := app.AccountKeeper.GetModuleAccount(ctx, "distribution")
    require.NotNil(t, retrievedAcc)
    
    // The retrieved account has the wrong name
    require.Equal(t, "attacker", retrievedAcc.GetName())
    require.NotEqual(t, "distribution", retrievedAcc.GetName())
    
    // This breaks the invariant that module accounts at address(X) should have name X
    // The distribution module would operate with an account named "attacker"
}
```

**Setup:** Creates a test app with default configuration.

**Trigger:** 
1. Creates a ModuleAccount with address derived from "distribution" but name set to "attacker"
2. Directly stores it using SetAccount (bypassing validation, similar to InitGenesis flow)
3. Retrieves it using GetModuleAccount("distribution")

**Observation:** 
The test demonstrates that:
1. The malicious account fails Validate() as expected
2. But SetAccount accepts it anyway (no validation enforcement)  
3. GetModuleAccount returns the wrong account (name="attacker" instead of "distribution")
4. This confirms the name-address binding is not enforced at critical points

This test will pass on the current codebase, proving the vulnerability exists. After implementing the recommended fixes, this test should fail/panic, confirming the validation is now enforced.

### Citations

**File:** x/auth/types/account.go (L227-229)
```go
	if ma.Address != sdk.AccAddress(crypto.AddressHash([]byte(ma.Name))).String() {
		return fmt.Errorf("address %s cannot be derived from the module name '%s'", ma.Address, ma.Name)
	}
```

**File:** x/auth/genesis.go (L22-24)
```go
	for _, a := range accounts {
		acc := ak.NewAccount(ctx, a)
		ak.SetAccount(ctx, acc)
```

**File:** x/auth/keeper/keeper.go (L146-157)
```go
// ValidatePermissions validates that the module account has been granted
// permissions within its set of allowed permissions.
func (ak AccountKeeper) ValidatePermissions(macc types.ModuleAccountI) error {
	permAddr := ak.permAddrs[macc.GetName()]
	for _, perm := range macc.GetPermissions() {
		if !permAddr.HasPermission(perm) {
			return fmt.Errorf("invalid module permission %s", perm)
		}
	}

	return nil
}
```

**File:** x/auth/keeper/keeper.go (L187-193)
```go
	acc := ak.GetAccount(ctx, addr)
	if acc != nil {
		macc, ok := acc.(types.ModuleAccountI)
		if !ok {
			panic("account is not a module account")
		}
		return macc, perms
```

**File:** x/auth/types/genesis.go (L86-104)
```go
func ValidateGenAccounts(accounts GenesisAccounts) error {
	addrMap := make(map[string]bool, len(accounts))

	for _, acc := range accounts {
		// check for duplicated accounts
		addrStr := acc.GetAddress().String()
		if _, ok := addrMap[addrStr]; ok {
			return fmt.Errorf("duplicate account found in genesis state; address: %s", addrStr)
		}

		addrMap[addrStr] = true

		// check account specific validation
		if err := acc.Validate(); err != nil {
			return fmt.Errorf("invalid account found in genesis state; address: %s, error: %s", addrStr, err.Error())
		}
	}
	return nil
}
```

**File:** x/genutil/client/cli/validate_genesis.go (L21-66)
```go
// ValidateGenesisCmd takes a genesis file, and makes sure that it is valid.
func ValidateGenesisCmd(mbm module.BasicManager) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "validate-genesis [file]",
		Args:  cobra.RangeArgs(0, 1),
		Short: "validates the genesis file at the default location or at the location passed as an arg",
		RunE: func(cmd *cobra.Command, args []string) (err error) {
			serverCtx := server.GetServerContextFromCmd(cmd)
			clientCtx := client.GetClientContextFromCmd(cmd)

			cdc := clientCtx.Codec

			isStream, err := cmd.Flags().GetBool(flagStreaming)
			if err != nil {
				panic(err)
			}

			if isStream {
				return validateGenesisStream(mbm, cmd, args)
			}

			// Load default if passed no args, otherwise load passed file
			var genesis string
			if len(args) == 0 {
				genesis = serverCtx.Config.GenesisFile()
			} else {
				genesis = args[0]
			}

			genDoc, err := validateGenDoc(genesis)
			if err != nil {
				return err
			}

			var genState map[string]json.RawMessage
			if err = json.Unmarshal(genDoc.AppState, &genState); err != nil {
				return fmt.Errorf("error unmarshalling genesis doc %s: %s", genesis, err.Error())
			}

			if err = mbm.ValidateGenesis(cdc, clientCtx.TxConfig, genState); err != nil {
				return fmt.Errorf("error validating genesis file %s: %s", genesis, err.Error())
			}

			fmt.Printf("File at %s is a valid genesis file\n", genesis)
			return nil
		},
```
