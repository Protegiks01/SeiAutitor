## Audit Report

## Title
Simulation Framework Bypasses Slashing Module Validator Liveness Checks, Masking Critical Consensus Bugs

## Summary
The simulation framework in `x/simulation/simulate.go` calls `FinalizeBlock` with an empty `RequestFinalizeBlock` struct, which contains no validator vote information. This causes the slashing module's `BeginBlocker` to skip all validator liveness checks, completely bypassing downtime tracking and slashing during simulations. This masks critical bugs in slashing logic that could halt production chains.

## Impact
**High** - This vulnerability allows consensus-breaking bugs in the slashing module to go undetected during simulation testing, potentially leading to total network shutdown in production.

## Finding Description

**Location:** [1](#0-0) [2](#0-1) 

**Intended Logic:** 
The simulation framework should test all consensus-critical code paths, including the slashing module's validator liveness tracking. The `RandomRequestBeginBlock` function is designed to generate realistic validator signing patterns to test slashing behavior. [3](#0-2) 

**Actual Logic:** 
While `RandomRequestBeginBlock` is called to generate validator vote information: [4](#0-3) [5](#0-4) 

The generated `request` variable is never used. Instead, `FinalizeBlock` is called with an empty struct that has no validator votes, causing the slashing checks to be skipped entirely.

When `FinalizeBlocker` constructs the `BeginBlock` request from the empty `RequestFinalizeBlock`: [6](#0-5) 

It creates a `LastCommitInfo` with empty votes. The slashing module's `BeginBlocker` then iterates over this empty list: [7](#0-6) 

With no votes to process, no validators are checked for liveness, and `HandleValidatorSignatureConcurrent` is never called with actual validator data: [8](#0-7) 

**Exploit Scenario:**
This is not an active exploit but a testing vulnerability. If the slashing logic contains bugs (e.g., panic conditions, integer overflows in `MissedBlocksCounter`, consensus-breaking state corruption, or logic that incorrectly jails all validators), these would never be triggered during simulation testing because the slashing code paths are never executed with actual validator data. Such bugs could cause production chain halts when validators are actually tracked for downtime.

**Security Failure:**
The simulation framework fails to test critical consensus safety mechanisms. This violates the testing invariant that simulations should exercise all consensus-critical code paths to catch bugs before production deployment.

## Impact Explanation

The concrete impacts are:

1. **Untested Consensus Logic**: The slashing module's downtime tracking mechanism is completely untested in simulations, despite being critical for validator accountability and chain liveness.

2. **Masked Production Bugs**: Bugs in slashing logic that would halt production chains remain undetected. For example:
   - A panic in `HandleValidatorSignatureConcurrent` would never be triggered
   - Integer overflow in missed block counters would never be caught
   - Logic errors that incorrectly jail all validators would never manifest
   - State corruption in the bit array tracking would never be detected

3. **Evidence of the Issue**: The codebase itself confirms this problem with a TODO comment in the slashing simulation operations: [9](#0-8) 

This comment states that unjailing is "almost, if not always, skipped" because validators never get jailed in simulationsâ€”direct evidence that the downtime slashing mechanism is not functioning.

4. **Chain Halt Risk**: If slashing logic contains a bug that jails all validators or causes a consensus failure, the entire network would halt and be unable to produce new blocks, requiring emergency intervention or a hard fork.

## Likelihood Explanation

**Triggering Conditions:**
- This issue is triggered in every simulation run
- It affects all simulation tests that use `SimulateFromSeed`
- The likelihood that undetected slashing bugs exist is moderate to high, given the complexity of the concurrent liveness tracking logic

**Frequency:**
- Every simulation run fails to test slashing logic
- Any existing or future bugs in the slashing module will remain undetected until they manifest in production

**Who Can Be Affected:**
- All network participants are affected if slashing bugs cause chain halts
- Validators are directly impacted if slashing logic malfunctions
- The entire network security depends on correct slashing behavior

## Recommendation

Fix the simulation framework to pass the generated `RequestFinalizeBlock` with proper validator vote information:

1. Modify `x/simulation/simulate.go` to construct a proper `RequestFinalizeBlock` from the `request` generated by `RandomRequestBeginBlock`
2. Pass validator votes from `request.LastCommitInfo.Votes` to the `DecidedLastCommit` field
3. Include byzantine validators from `request.ByzantineValidators` 
4. Ensure all header fields (height, time, proposer, etc.) are properly populated

This will enable the slashing module's `BeginBlocker` to process validator signatures during simulations, allowing proper testing of downtime tracking and slashing logic.

## Proof of Concept

**File:** `x/simulation/simulate_test.go` (new test file)

**Test Function:** `TestSlashingLogicExecutedInSimulation`

**Setup:**
1. Initialize a simulation app with slashing and staking modules enabled
2. Create multiple validators in the genesis state
3. Configure slashing parameters to have a low threshold (e.g., `SignedBlocksWindow: 10`, `MinSignedPerWindow: 0.5`)

**Trigger:**
1. Run a simulation for multiple blocks using `SimulateFromSeed`
2. Query the slashing keeper to check if any validator signing info has been updated
3. Check if any `MissedBlocksCounter` values are non-zero
4. Verify if any validators have been jailed for downtime

**Observation:**
The test will observe that:
- No validator signing info shows missed blocks being tracked
- All `MissedBlocksCounter` values remain at 0
- No validators are ever jailed for downtime despite the simulation running for many blocks
- The event logs show no "signing" or "missed" events from the slashing module

This confirms that the slashing logic is not being executed during simulations, validating the vulnerability.

**Expected vs Actual:**
- **Expected**: With realistic validator signing patterns (some validators missing blocks), the slashing module should track missed blocks, increment counters, and eventually jail validators who exceed the threshold
- **Actual**: No validator liveness tracking occurs, no counters are updated, and no slashing events are emitted, proving the slashing logic is bypassed

### Citations

**File:** x/simulation/simulate.go (L132-133)
```go
	request := RandomRequestBeginBlock(r, params,
		validators, pastTimes, pastVoteInfos, eventStats.Tally, header)
```

**File:** x/simulation/simulate.go (L173-173)
```go
		app.FinalizeBlock(context.Background(), &abci.RequestFinalizeBlock{})
```

**File:** x/simulation/simulate.go (L193-193)
```go
		res, _ := app.FinalizeBlock(context.Background(), &abci.RequestFinalizeBlock{})
```

**File:** x/simulation/simulate.go (L214-215)
```go
		// for the next block
		request = RandomRequestBeginBlock(r, params, validators, pastTimes, pastVoteInfos, eventStats.Tally, header)
```

**File:** x/simulation/mock_tendermint.go (L117-218)
```go
// RandomRequestBeginBlock generates a list of signing validators according to
// the provided list of validators, signing fraction, and evidence fraction
func RandomRequestBeginBlock(r *rand.Rand, params Params,
	validators mockValidators, pastTimes []time.Time,
	pastVoteInfos [][]abci.VoteInfo,
	event func(route, op, evResult string), header tmproto.Header) abci.RequestBeginBlock {
	if len(validators) == 0 {
		return abci.RequestBeginBlock{
			Header: header,
		}
	}

	voteInfos := make([]abci.VoteInfo, len(validators))

	for i, key := range validators.getKeys() {
		mVal := validators[key]
		mVal.livenessState = params.LivenessTransitionMatrix().NextState(r, mVal.livenessState)
		signed := true

		if mVal.livenessState == 1 {
			// spotty connection, 50% probability of success
			// See https://github.com/golang/go/issues/23804#issuecomment-365370418
			// for reasoning behind computing like this
			signed = r.Int63()%2 == 0
		} else if mVal.livenessState == 2 {
			// offline
			signed = false
		}

		if signed {
			event("begin_block", "signing", "signed")
		} else {
			event("begin_block", "signing", "missed")
		}

		pubkey, err := cryptoenc.PubKeyFromProto(mVal.val.PubKey)
		if err != nil {
			panic(err)
		}

		voteInfos[i] = abci.VoteInfo{
			Validator: abci.Validator{
				Address: pubkey.Address(),
				Power:   mVal.val.Power,
			},
			SignedLastBlock: signed,
		}
	}

	// return if no past times
	if len(pastTimes) == 0 {
		return abci.RequestBeginBlock{
			Header: header,
			LastCommitInfo: abci.LastCommitInfo{
				Votes: voteInfos,
			},
		}
	}

	// TODO: Determine capacity before allocation
	evidence := make([]abci.Evidence, 0)

	for r.Float64() < params.EvidenceFraction() {
		height := header.Height
		time := header.Time
		vals := voteInfos

		if r.Float64() < params.PastEvidenceFraction() && header.Height > 1 {
			height = int64(r.Intn(int(header.Height)-1)) + 1 // Tendermint starts at height 1
			// array indices offset by one
			time = pastTimes[height-1]
			vals = pastVoteInfos[height-1]
		}

		validator := vals[r.Intn(len(vals))].Validator

		var totalVotingPower int64
		for _, val := range vals {
			totalVotingPower += val.Validator.Power
		}

		evidence = append(evidence,
			abci.Evidence{
				Type:             abci.MisbehaviorType_DUPLICATE_VOTE,
				Validator:        validator,
				Height:           height,
				Time:             time,
				TotalVotingPower: totalVotingPower,
			},
		)

		event("begin_block", "evidence", "ok")
	}

	return abci.RequestBeginBlock{
		Header: header,
		LastCommitInfo: abci.LastCommitInfo{
			Votes: voteInfos,
		},
		ByzantineValidators: evidence,
	}
}
```

**File:** simapp/app.go (L476-504)
```go
func (app *SimApp) FinalizeBlocker(ctx sdk.Context, req *abci.RequestFinalizeBlock) (*abci.ResponseFinalizeBlock, error) {
	events := []abci.Event{}
	beginBlockResp := app.BeginBlock(ctx, abci.RequestBeginBlock{
		Hash: req.Hash,
		ByzantineValidators: utils.Map(req.ByzantineValidators, func(mis abci.Misbehavior) abci.Evidence {
			return abci.Evidence{
				Type:             abci.MisbehaviorType(mis.Type),
				Validator:        abci.Validator(mis.Validator),
				Height:           mis.Height,
				Time:             mis.Time,
				TotalVotingPower: mis.TotalVotingPower,
			}
		}),
		LastCommitInfo: abci.LastCommitInfo{
			Round: req.DecidedLastCommit.Round,
			Votes: utils.Map(req.DecidedLastCommit.Votes, func(vote abci.VoteInfo) abci.VoteInfo {
				return abci.VoteInfo{
					Validator:       abci.Validator(vote.Validator),
					SignedLastBlock: vote.SignedLastBlock,
				}
			}),
		},
		Header: tmproto.Header{
			ChainID:         app.ChainID,
			Height:          req.Height,
			Time:            req.Time,
			ProposerAddress: ctx.BlockHeader().ProposerAddress,
		},
	})
```

**File:** x/slashing/abci.go (L28-50)
```go
	// Iterate over all the validators which *should* have signed this block
	// store whether or not they have actually signed it and slash/unbond any
	// which have missed too many blocks in a row (downtime slashing)

	// this allows us to preserve the original ordering for writing purposes
	slashingWriteInfo := make([]*SlashingWriteInfo, len(req.LastCommitInfo.GetVotes()))

	allVotes := req.LastCommitInfo.GetVotes()
	for i, _ := range allVotes {
		wg.Add(1)
		go func(valIndex int) {
			defer wg.Done()
			vInfo := allVotes[valIndex]
			consAddr, missedInfo, signInfo, shouldSlash, slashInfo := k.HandleValidatorSignatureConcurrent(ctx, vInfo.Validator.Address, vInfo.Validator.Power, vInfo.SignedLastBlock)
			slashingWriteInfo[valIndex] = &SlashingWriteInfo{
				ConsAddr:    consAddr,
				MissedInfo:  missedInfo,
				SigningInfo: signInfo,
				ShouldSlash: shouldSlash,
				SlashInfo:   slashInfo,
			}
		}(i)
	}
```

**File:** x/slashing/keeper/infractions.go (L20-124)
```go
// This performs similar logic to the above HandleValidatorSignature, but only performs READs such that it can be performed in parallel for all validators.
// Instead of updating appropriate validator bit arrays / signing infos, this will return the pending values to be written in a consistent order
func (k Keeper) HandleValidatorSignatureConcurrent(ctx sdk.Context, addr cryptotypes.Address, power int64, signed bool) (consAddr sdk.ConsAddress, missedInfo types.ValidatorMissedBlockArray, signInfo types.ValidatorSigningInfo, shouldSlash bool, slashInfo SlashInfo) {
	logger := k.Logger(ctx)
	height := ctx.BlockHeight()

	// fetch the validator public key
	consAddr = sdk.ConsAddress(addr)
	if _, err := k.GetPubkey(ctx, addr); err != nil {
		panic(fmt.Sprintf("Validator consensus-address %s not found", consAddr))
	}

	// fetch signing info
	signInfo, found := k.GetValidatorSigningInfo(ctx, consAddr)
	if !found {
		panic(fmt.Sprintf("Expected signing info for validator %s but not found", consAddr))
	}

	window := k.SignedBlocksWindow(ctx)

	index := signInfo.IndexOffset

	missedInfo, found = k.GetValidatorMissedBlocks(ctx, consAddr)

	if !found {
		arrLen := (window + UINT_64_NUM_BITS - 1) / UINT_64_NUM_BITS
		missedInfo = types.ValidatorMissedBlockArray{
			Address:      consAddr.String(),
			WindowSize:   window,
			MissedBlocks: make([]uint64, arrLen),
		}
	}
	if found && missedInfo.WindowSize != window {
		missedInfo, signInfo, index = k.ResizeMissedBlockArray(missedInfo, signInfo, window, index)
	}
	previous := k.GetBooleanFromBitGroups(missedInfo.MissedBlocks, index)
	missed := !signed
	missedInfo.MissedBlocks = k.SetBooleanInBitGroups(missedInfo.MissedBlocks, index, missed)
	switch {
	case !previous && missed:
		// Array value has changed from not missed to missed, increment counter
		signInfo.MissedBlocksCounter++
	case previous && !missed:
		// Array value has changed from missed to not missed, decrement counter
		signInfo.MissedBlocksCounter--
	default:
		// Array value at this index has not changed, no need to update counter
	}

	// bump index offset (and mod circular) after performing potential resizing
	signInfo.IndexOffset = (signInfo.IndexOffset + 1) % window

	minSignedPerWindow := k.MinSignedPerWindow(ctx)
	if missed {
		ctx.EventManager().EmitEvent(
			sdk.NewEvent(
				types.EventTypeLiveness,
				sdk.NewAttribute(types.AttributeKeyAddress, consAddr.String()),
				sdk.NewAttribute(types.AttributeKeyMissedBlocks, fmt.Sprintf("%d", signInfo.MissedBlocksCounter)),
				sdk.NewAttribute(types.AttributeKeyHeight, fmt.Sprintf("%d", height)),
			),
		)

		logger.Debug(
			"absent validator",
			"height", height,
			"validator", consAddr.String(),
			"missed", signInfo.MissedBlocksCounter,
			"threshold", minSignedPerWindow,
		)
	}

	minHeight := signInfo.StartHeight + window
	maxMissed := window - minSignedPerWindow
	shouldSlash = false
	// if we are past the minimum height and the validator has missed too many blocks, punish them
	if height > minHeight && signInfo.MissedBlocksCounter > maxMissed {
		validator := k.sk.ValidatorByConsAddr(ctx, consAddr)
		if validator != nil && !validator.IsJailed() {
			// Downtime confirmed: slash and jail the validator
			// We need to retrieve the stake distribution which signed the block, so we subtract ValidatorUpdateDelay from the evidence height,
			// and subtract an additional 1 since this is the LastCommit.
			// Note that this *can* result in a negative "distributionHeight" up to -ValidatorUpdateDelay-1,
			// i.e. at the end of the pre-genesis block (none) = at the beginning of the genesis block.
			// That's fine since this is just used to filter unbonding delegations & redelegations.
			shouldSlash = true
			distributionHeight := height - sdk.ValidatorUpdateDelay - 1
			slashInfo = SlashInfo{
				height:             height,
				power:              power,
				distributionHeight: distributionHeight,
				minHeight:          minHeight,
				minSignedPerWindow: minSignedPerWindow,
			}
			// This value is passed back and the validator is slashed and jailed appropriately
		} else {
			// validator was (a) not found or (b) already jailed so we do not slash
			logger.Info(
				"validator would have been slashed for downtime, but was either not found in store or already jailed",
				"validator", consAddr.String(),
			)
		}
	}
	return
}
```

**File:** x/slashing/simulation/operations.go (L62-64)
```go
		if !validator.IsJailed() {
			// TODO: due to this condition this message is almost, if not always, skipped !
			return simtypes.NoOpMsg(types.ModuleName, types.TypeMsgUnjail, "validator is not jailed"), nil, nil
```
